<html>
  <head>
    <title></title>
    <meta content="">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-16" />
    <script type="text/javascript" src="../js/jquery-1.11.3.js"></script>
    <script type="text/javascript" src="../js/evaluation.js"></script>
    <script type="text/javascript" src="../js/parser.js"></script>
    <style>
    .result {
    	margin-left: auto;
    	margin-right: auto;
    	margin-bottom: 2px;
    	width: 350px;
    	height: 18px;
    	padding: 5px;
    }
    .summary {
    	margin-left: auto;
    	margin-right: auto;
    	margin-bottom: 2px;
    	width: 360px;
    	height: 23px;
    	padding: 8px;
    }
    .expr {
    	font-style: italic;
    }
    .pass {
    	background-color: #69B288;
    }
    .fail {
    	background-color: #B25E57;
    }

    .test-group {
        float: left;
        margin-left: 5px;
    }

    .title {
        font-weight: bold;
    }
    </style>
  </head>
  <body>
    <div id="eval" class="test-group">
    </div>
    <div id="parse" class="test-group">
    </div>

  </body>
<script type="text/javascript">
var total = 0;
var passed = 0;

function performLogicTest(message, expr, expected, scope, succ) {
	total++;
	var eval = evaluate(expr, scope);
	var pass = (eval === expected) === succ;
	if (pass) passed++;

	$('#eval').append($('<div/>', {'class':'result ' + ((pass) ? 'pass' : 'fail') })
        .text('Test ' + total + ': ').append($('<span/>', {'class':'expr'}).text(message)));
 //TODO show when a negative result expected
}

function performParserTest(input, expected, succ){
    total++;
	var tree = parse(input);
    var pass = compareTree(tree, expected) === succ;
	if(pass){
		passed++;
    } else if (total === 14) {
        console.log(tree, expected);
    }
    $('#parse').append($('<div/>', {'class':'result ' + ((pass) ? 'pass' : 'fail') })
        .text('Test ' + total + ': ').append($('<span/>', {'class':'expr'}).text(input)));
}
 var first = true;

//Compares two tree like structures as seen in the parser - Compares two nodes
function compareTree(x,y){
	if(x === y) return true; //If both x and y are null or undefined and exactly the same - return true

	if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false; //If one or both are not strictly objects - they need to be - return false

	if(x.type == "CONST") return(x.type == y.type && x.val == y.val);
	else if(x.type == "VAR_ACCESS") return x.type == y.type && x.val == y.val && x.field == y.field;

	return compareTree(x.first, y.first) && compareTree(x.second, y.second) && x.type == y.type;
}

function concludeTests(selector, title){
	$(selector).prepend($('<div/>', {'class':'summary ' + ((total === passed) ? 'pass' : 'fail') })
		 .text(passed + ' out of ' + total + ' tests passed.').prepend($('<span/>', {'class':'title'}).text(title + ': ')));
    total = 0;
    passed = 0;

}

var expression = {
	type:"SOME",
	first: 'p',
	second: {
		type: 'EQUALS',
		first: {type: 'CONST', val: 7},
		second: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}
	}
};

var world = [{x: 3, y: 2},
			 {x: 5, y: 2},
			 {x: 8, y: 4},
			 {x: 1, y: 3}
			];

performLogicTest('some p | 7 = p.x', expression, false, {}, true);


//Tests for the Evaluation Method

//Test field access
performLogicTest('p.x', {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, 1, { p: {x: 1, y: 2}}, true);
performLogicTest('q.x', {type: 'VAR_ACCESS', vari: 'q', field: 'x'}, 3, { p: {x: 1, y: 2}, q: {x: 3, y: 2}}, true);

//Const
performLogicTest('4 is int', {type: 'CONST', val: 4}, 4, {}, true);
performLogicTest('4 is not string', {type: 'CONST', val: 4}, '4', {}, false);

//Implies
performLogicTest('true -> false is false', {type: 'IMPLIES', first: {type: 'CONST', val: true}, second: {type: 'CONST', val: false}}, false, {}, true);
performLogicTest('false -> false', {type: 'IMPLIES', first: {type: 'CONST', val: false}, second: {type: 'CONST', val: false}}, true, {}, true);
//More tests
//{type: , first: , second: }

//Some p . p.x = 3 and p.y = 2 (should be true)
performLogicTest('some p | p.x = 3 and p.y = 2', {type: 'SOME', first: 'p', second: {type: 'AND', first: {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 3}},
 second: {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 2}}}}, true, {}, true);

//All p . p.x < 10 or p.y > 3 (should be true)
performLogicTest('all p | p.x < 10 or p.y > 3', {type: 'ALL', first: 'p', second: {type: 'OR', first: {type: 'LESS_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 10}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 3}}}}, true, {}, true);

//All p . p.x < 10 and p.y > 3 (should be false)
performLogicTest('all p | p.x < 10 and p.y > 3 is false', {type: 'ALL', first: 'p', second: {type: 'AND', first: {type: 'LESS_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 10}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 3}}}}, true, {}, false);

//All p . p.x != p.y (should be true)
performLogicTest('all p | p.x != p.y', {type: 'ALL', first: 'p', second: {type: 'NOT_EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}}}, true, {}, true);

//Some p . p.x == p.y (should be false)
performLogicTest('some p | p.x == p.y is false', {type: 'SOME', first: 'p', second: {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}}}, true, {}, false);

//Some p, q . p.x == q.y (should be true)
performLogicTest('some p, q . p.x == q.y', {type: 'SOME', first: 'p', second: {type: 'SOME', first: 'q', second: {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'q', field: 'y'}}}}, true, {}, true);

//All p, q . p != q -> p.y != q.y (should be false)
performLogicTest('all p, q | p != q -> p.y != q.y is false', {type: 'ALL', first: 'p', second: {type: 'ALL', first: 'q', second:
{type: 'IMPLIES', first: {type: 'NOT_EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: null}, second: {type: 'VAR_ACCESS', vari: 'q', field: null}}, 
second: {type: 'NOT_EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'VAR_ACCESS', vari: 'q', field: 'y'}}}}}, true, {}, false);

//Some p, q . p = q (should be true)
performLogicTest('some p, q | p = q', {type: 'SOME', first: 'p', second: {type: 'SOME', first: 'q', second: {type: 'NOT_EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: null}, second: {type: 'VAR_ACCESS', vari: 'q', field: null}}}}, true, {}, true);


//All p . p.x > 6 iff p.y > 2 (should be false)
performLogicTest('all p | p.x > 6 iff p.y > 2 is false', {type: 'ALL', first: 'p', second: {type: 'IFF', first: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 6}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 2}}}}, true, {}, false);

//Some p . p.x > 6 iff p.y > 2 (should be true)
performLogicTest('some p | p.x > 6 iff p.y > 2 ', {type: 'SOME', first: 'p', second: {type: 'IFF', first: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 6}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 2}}}}, true, {}, true);

//Some p . p.x == 8 and (All q . p.y >= q.y) (should be true)
performLogicTest('some p | p.x == 8 and (All q . p.y >= q.y)', {type: 'SOME', first: 'p', second: {type: 'AND', first: {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 8}},
 second: {type: 'ALL', first: 'q', second: {type: 'GTE', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'VAR_ACCESS', vari: 'q', field: 'y'} } }}}, true, {}, true);


concludeTests('#eval', 'Evaluator');





//Tests for the Parser

//behaviour of '"string"'' or 'string' as string constants
performParserTest("a.b", {type: 'VAR_ACCESS', vari:'a', field:'b'}, true);
performParserTest("a. b", {type: 'VAR_ACCESS', vari:'a', field:'b'}, false);

performParserTest("¬a.b", {type: 'NOT', first: {type: 'VAR_ACCESS', vari:'a', field:'b'}, second: null}, true);

performParserTest("a.b=b.a", {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari:'a', field:'b'}, second: {type: 'VAR_ACCESS', vari:'b', field:'a'}}, true);

performParserTest("a.b = b.a", {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari:'a', field:'b'}, second: {type: 'VAR_ACCESS', vari:'b', field:'a'}}, true);

performParserTest("a.b\u2227b.a", {type: 'AND', first: {type: 'VAR_ACCESS', vari:'a', field:'b'}, second: {type: 'VAR_ACCESS', vari:'b', field:'a'}}, true);

performParserTest("a.b\u2228b.a", {type: 'OR', first: {type: 'VAR_ACCESS', vari:'a', field:'b'}, second: {type: 'VAR_ACCESS', vari:'b', field:'a'}}, true);

performParserTest("a.b!=b.a", {type: 'NOT_EQUALS', first: {type: 'VAR_ACCESS', vari:'a', field:'b'}, second: {type: 'VAR_ACCESS', vari:'b', field:'a'}}, true);

// not(a AND not(b))
performParserTest("(a\u2227b)\u2228(c\u2227d)", {type: 'OR', first: {type: 'AND', first: {type: 'VAR_ACCESS', vari: 'a', field: null}, second: {type: 'VAR_ACCESS', vari: 'b', field: null}}, second: {type: 'AND', first: {type: 'VAR_ACCESS', vari: 'c', field: null}, second: {type: 'VAR_ACCESS', vari: 'd', field: null}}}, true);

performParserTest("¬(a\u2227¬b)", {type: 'NOT', first: {type: 'AND', first: {type: 'VAR_ACCESS', vari:'a', field:null}, second: {type: 'NOT', first: {type: 'VAR_ACCESS', vari: 'b', field: null}, second: null}
    }, second: null}, true);

// for all a | a.x = 3
performParserTest("\u2200a\u22C5a.x=3", {type: 'ALL', first: 'a', second: {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari: 'a', field: 'x'}, second: {type: 'CONST', val: 3}}}, true);

// some p | p.x < p.y
performParserTest("\u2203p\u22C5p.x<p.y", {type: 'SOME', first: 'p', second: {type: 'LESS_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}}}, true);

// ¬(¬b) = b
performParserTest("¬(¬b)\u2194b", {type: 'IFF', first: {type: 'NOT', first: {type: 'NOT', first: {type: 'VAR_ACCESS', vari: 'b', field: null}, second: null}, second: null}, second: {type: 'VAR_ACCESS', vari: 'b', field: null}}, true);

// ((a AND not(b)) AND b) OR (c AND d) AND not(a AND c)
//TODO: Rewrite due to it currently being broken
//performParserTest("((a\u2227(¬b))\u2227b)\u2228(c\u2227d)\u2227¬(a\u2227c)", {type: 'OR', first: {type: 'AND', first: {type: 'AND', first: {type: 'VAR_ACCESS', vari: 'a', field: null}, second: {type: 'NOT', first: {type: 'VAR_ACCESS', vari: 'b', field: null}, second: null}, second: {type: 'VAR_ACCESS', vari: 'b', field: null}}}, second: {}}, true);

// a != b
performParserTest("a!=b", {type: 'NOT_EQUALS', first: {type: 'VAR_ACCESS', vari: 'a', field: null}, second: {type: 'VAR_ACCESS', vari: 'b', field: null}});

// p.x != p.y
performParserTest("a!=b", {type: 'NOT_EQUALS', first: {type: 'VAR_ACCESS', vari: 'a', field: null}, second: {type: 'VAR_ACCESS', vari: 'b', field: null}});

performParserTest("a\u2227b\u2228c\u2227d", {type: 'OR', first: {type: 'AND', first: {type: 'VAR_ACCESS', vari: 'a', field: null}, second: {type: 'VAR_ACCESS', vari: 'b', field: null}}, second: {type: 'AND', first: {type: 'VAR_ACCESS', vari: 'c', field: null}, second: {type: 'VAR_ACCESS', vari: 'd', field: null}}});

// some p,q | p.x = q.x
performParserTest("\u2203p,q\u22C5p.x=q.x", {type: 'SOME', first: 'p', second: {type: 'SOME', first: 'q', second: {type: 'EQUALS', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'q', field: 'x'}}}}, true);

// not(a) AND b
performParserTest("¬a\u2227b", {type: 'AND', first: {type: 'NOT', first: {type: 'VAR_ACCESS', vari: 'a', field: null}, second: null}, second: {type: 'VAR_ACCESS', vari: 'b', field: null}});







//Tests line ab\u2227b!=c.d
performParserTest("ab\u2227b!=c.d", {type: "AND", first: {type: "VAR_ACCESS", val: "ab", field: null}, second: {type: "NOT_EQUALS", first:{type: "VAR_ACCESS", val: "b", field: null}, second:{type:"VAR_ACCESS", val: "c", field: "d"}}}, true);

concludeTests('#parse', 'Parser');

//tests line \u2203x.x=1
//performParserTest('Parser: Input line \u2203x.x=1', "\u2203x.x=1", {type:"ALL", first:"x", second:{type: "EQUALSS", first:{type:"VAR_ACCESS, val: "x", field: null}, second:{type:"CONST", val:"x"}}}, true);

//Tests for compatibility between parser and evaluator

</script>
</html>
