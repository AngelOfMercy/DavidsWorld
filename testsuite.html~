<html>
  <head>
    <title></title>
    <meta content="">
    <script type="text/javascript" src="js/jquery-1.11.3.js"></script>
    <script type="text/javascript" src="evaluation.js"></script>
    <script type="text/javascript" src="parser.js"></script>
    <style>
    .result {
    	margin-left: auto;
    	margin-right: auto;
    	margin-bottom: 2px;
    	width: 350px;
    	height: 18px;
    	padding: 5px;
    }
    .summary {
    	margin-left: auto;
    	margin-right: auto;
    	margin-bottom: 2px;
    	width: 360px;
    	height: 23px;
    	padding: 8px;
    }
    .expr {
    	font-style: italic;
    }
    .pass {
    	background-color: #69B288;
    }
    .fail {
    	background-color: #B25E57;
    }
    </style>
  </head>
  <body>


  </body>
<script type="text/javascript">
var total = 0;
var passed = 0;

function performLogicTest(message, expr, expected, scope, succ) {
	total++;
	var eval = evaluate(expr, scope);
	var pass = (eval === expected) === succ;
	if (pass) passed++;
	$('body').append($('<div/>', {'class':'result ' + ((pass) ? 'pass' : 'fail') })
		.html('Test ' + total + ': <span class="expr">'+message+'</span>')); //TODO show when a negative result expected
}

function performParserTest(message, input, expected, succ){
        total++;
	var tree = parse(input);
        var pass = compareTree(tree, expected) === succ;
	if(pass){
		passed++;
   }
 $('body').append($('<div/>', {'class':'result ' + ((pass) ? 'pass' : 'fail') })
		.html('Test ' + total + ': <span class="expr">'+message+'</span>'));
}
 var first = true;

//Compares two tree like structures as seen in the parser - Compares two nodes
function compareTree(x,y){
 if (first) {
 console.log(x,y);
 first = false;
}
	if(x === y) return true; //If both x and y are null or undefined and exactly the same - return true

	if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false; //If one or both are not strictly objects - they need to be - return false

	if(x.type == "CONST") return(x.type == y.type && x.val == y.val);
	else if(x.type == "VAR_ACCESS") return x.type == y.type && x.val == y.val && x.field == y.field;

	return compareTree(x.first, y.first) && compareTree(x.second, y.second) && x.type == y.type;
}

function concludeTests(){
	$('body').prepend($('<div/>', {'class':'summary ' + ((total === passed) ? 'pass' : 'fail') })
		.text(passed + ' out of ' + total + ' tests passed.')); 
}

var expression = {
	type:"SOME",
	first: 'p',
	second: {
		type: 'EQUAL',
		first: {type: 'CONST', val: 7},
		second: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}
	}
};

var world = [{x: 3, y: 2},
			 {x: 5, y: 2},
			 {x: 8, y: 4},
			 {x: 1, y: 3}
			];

performLogicTest('some p | 7 = p.x', expression, false, {}, true);


//Tests for the Evaluation Method

//Test field access
performLogicTest('p.x', {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, 1, { p: {x: 1, y: 2}}, true);
performLogicTest('q.x', {type: 'VAR_ACCESS', vari: 'q', field: 'x'}, 3, { p: {x: 1, y: 2}, q: {x: 3, y: 2}}, true);

//Const
performLogicTest('4 is int', {type: 'CONST', val: 4}, 4, {}, true);
performLogicTest('4 is not string', {type: 'CONST', val: 4}, '4', {}, false);

//Implies
performLogicTest('true -> false is false', {type: 'IMPLIES', first: {type: 'CONST', val: true}, second: {type: 'CONST', val: false}}, false, {}, true);
performLogicTest('false -> false', {type: 'IMPLIES', first: {type: 'CONST', val: false}, second: {type: 'CONST', val: false}}, true, {}, true);
//More tests
//{type: , first: , second: }

//Some p . p.x = 3 and p.y = 2 (should be true)
performLogicTest('some p | p.x = 3 and p.y = 2', {type: 'SOME', first: 'p', second: {type: 'AND', first: {type: 'EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 3}},
 second: {type: 'EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 2}}}}, true, {}, true);

//All p . p.x < 10 or p.y > 3 (should be true)
performLogicTest('all p | p.x < 10 or p.y > 3', {type: 'ALL', first: 'p', second: {type: 'OR', first: {type: 'LESS_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 10}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 3}}}}, true, {}, true);

//All p . p.x < 10 and p.y > 3 (should be false)
performLogicTest('all p | p.x < 10 and p.y > 3 is false', {type: 'ALL', first: 'p', second: {type: 'AND', first: {type: 'LESS_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 10}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 3}}}}, true, {}, false);

//All p . p.x != p.y (should be true)
performLogicTest('all p | p.x != p.y', {type: 'ALL', first: 'p', second: {type: 'NOT_EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}}}, true, {}, true);

//Some p . p.x == p.y (should be false)
performLogicTest('some p | p.x == p.y is false', {type: 'SOME', first: 'p', second: {type: 'EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}}}, true, {}, false);

//Some p, q . p.x == q.y (should be true)
performLogicTest('some p, q . p.x == q.y', {type: 'SOME', first: 'p', second: {type: 'SOME', first: 'q', second: {type: 'EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'VAR_ACCESS', vari: 'q', field: 'y'}}}}, true, {}, true);

//All p, q . p != q -> p.y != q.y (should be false)
performLogicTest('all p, q | p != q -> p.y != q.y is false', {type: 'ALL', first: 'p', second: {type: 'ALL', first: 'q', second:
{type: 'IMPLIES', first: {type: 'NOT_EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: null}, second: {type: 'VAR_ACCESS', vari: 'q', field: null}}, 
second: {type: 'NOT_EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'VAR_ACCESS', vari: 'q', field: 'y'}}}}}, true, {}, false);

//Some p, q . p = q (should be true)
performLogicTest('some p, q | p = q', {type: 'SOME', first: 'p', second: {type: 'SOME', first: 'q', second: {type: 'NOT_EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: null}, second: {type: 'VAR_ACCESS', vari: 'q', field: null}}}}, true, {}, true);


//All p . p.x > 6 iff p.y > 2 (should be false)
performLogicTest('all p | p.x > 6 iff p.y > 2 is false', {type: 'ALL', first: 'p', second: {type: 'IFF', first: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 6}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 2}}}}, true, {}, false);

//Some p . p.x > 6 iff p.y > 2 (should be true)
performLogicTest('some p | p.x > 6 iff p.y > 2 ', {type: 'SOME', first: 'p', second: {type: 'IFF', first: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 6}},
 second: {type: 'GREATER_THAN', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'CONST', val: 2}}}}, true, {}, true);

//Some p . p.x == 8 and (All q . p.y >= q.y) (should be true)
performLogicTest('some p | p.x == 8 and (All q . p.y >= q.y)', {type: 'SOME', first: 'p', second: {type: 'AND', first: {type: 'EQUAL', first: {type: 'VAR_ACCESS', vari: 'p', field: 'x'}, second: {type: 'CONST', val: 8}},
 second: {type: 'ALL', first: 'q', second: {type: 'GTE', first: {type: 'VAR_ACCESS', vari: 'p', field: 'y'}, second: {type: 'VAR_ACCESS', vari: 'q', field: 'y'} } }}}, true, {}, true);








//Tests for the Parser

//Tests line ab\u2227b!=c.d
performParserTest('Parser: Input line ab\u2227b!=c.d', "ab\u2227b!=c.d", {type: "AND", first: {type: "VAR_ACCESS", val: "ab", field: null}, second: {type: "NOT_EQUAL", first:{type: "VAR_ACCESS", val: "b", field: null}, second:{type:"VAR_ACCESS", val: "c", field: "d"}}}, true);

//tests line \u2203x.x=1
//performParsertest('Parser: Input line \u2203x.x=1', "\u2203x.x=1", {type:"ALL", first:"x", second:{type: "EQUALS", first:{type:"VAR_ACCESS, val: "x", field: null}, second:{type:"CONST", val:"x"}}}, true);

//Tests for compatibility between parser and evaluator





concludeTests();
</script>
</html>
